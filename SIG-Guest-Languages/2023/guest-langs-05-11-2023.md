## May 11, 2023


|          |      | 
| -------- | -------- |
| Attending  | Robin Brown, Joel, Kevin Smith, Saúl Cabrera, Peter Vetere
| Note Taker | Robin Brown

* Updates
    * Robin: Announcement for subgroup vote is for next week
    * ...
    * Joel: 
*  [Joel] - Wasm-Dylib
    * Joel:The idea is that it could be used as a command line tool or libary. It would take in a main module and some number of dynamic libraries (in the emscripten format) and the tool would output a component that embeds those modules and links them up and hopefully breaks cycles by setting up function tables and doing indirect calls. It's not clear whether LLVM does this for us or we would have to do it in the tool. It might need to do some modification of modules to cycle break, but beyond that is just combining them into a component that links them at instantiation time. The main problem is that Wizer doesn't support Components. We want to use Wizer, so our interim step is to take in modules and produce a new Module by doing the linking there, then feeding it into Wizer, then into `wit-component`
    * Joel: The big challenge we're working through with Alex, Emscripten folks, etc. are working on `wasi-sdk` and `wasi libc` and there's no guarantee of backwards compatibility over time with releases, which would help us tell a story to Python folks that it will work with newer versoins of wasi libc but Dan has insisted correctly that we can't guarantee that until we have someone working on it full time. Any library that depends on wasi libc will need to explicitly depend on a version and if you have a mismatch it won't work. In practice it might work, but it's not guaranteed and can't be relied on and Dan who is working on other things can't commit to that.
    * Joel: what that means for the Python community is that when you choose a version of Python (e.g. 3.11 and its ABI) that implies a version of `wasi-sdk` and you can't go up or down with that version while using it. If numpy wants to publish a new version it might need a separate toolchain for each version of wasi sdk.
    * Kevin: The windows versions of Python are kind of like that but probably aren't that bad. I've definitely made a lot of versions of Python for a different windows version and had it work but...
    * Kevin: It'd be great if Anaconda could do this all for us and build the whole toolchain.
* [Joel] - Libc
    * Joel: One of the things that came up when discussing libc was setjmp longjmp which is something that Ruby needs. The expectation is that wasi libc will implement that at some point when exception handling goes in (and also stack switching).
* [Robin] - Selecting a Chair or Co-Chairs
    * Discussion that sug
* [] - 
    * Joel: The linking format defines a custom section that must appear at the beginning that identifies it as a dynamic library. It has subsections that identify what dependencies it has. Eventually we'll want two-level namespaces that identify the module you want something from and then what you want, but for right now if we want to go with the flow with what LLVM is producing it's going to be ELF style with just a global namespace. Code that needs to be called has to be position independent which means it can be placed anywhere in memory based on an offset table and its a little more complicated in Wasm because there's linear memory offsets and function table offsets. Where did your function table get placed in the index space? All this is going to get handled by this thing at linktime. The other thing tha'ts not defined is synthesized dlopen and dlsim functions and maybe even a virtual file system so that libraries pretend to exist on disk so that Python can think its loading libraries at runtime.
        * https://github.com/WebAssembly/tool-conventions/blob/main/DynamicLinking.md
        * https://hackmd.io/IlY4lICRRNy9wQbNLdb2Wg
    * Joel: The wasm32-unknown-emscripten target triple and wasm32-wasi (aka wasm32-unknown-wasi) will become consistent in an upcoming version of LLVM in terms of code generation and you should be able to use modules generated by both of them interchangeably.
* [Saúl] - JavaScript Compilation
    * Robin: 
    * Saúl: The compilation is using SpiderMonkey's first baseline compiler which requires a specialization and what we're doing is compiling it to Wasm instead. This involves running the interpreter.
    * Joel: Does this involve running the interpreter at runtime?
    * Saúl: Yes input samples and sample programs. The program would be the one that you're trying to AOT compile. So what samples do you have to sa
    * Saúl: Depending on which platform you're trying to extend, there's different APIs and there's very specific things you can 
    * Robin: the user doesn't need to write their own samples because for one of these APIs you know some examples 
    * Saúl: Generalizing Igalia so that you can use it for arbitrary applications instead of constraining it to known APIs is something that would happen in a next iteration.
    * Joel: You could imagine that if you have APIs defined in TypeScript you could trust that sometimes and optimize.
    * Saúl: Igalia is in the process of upstreaming these into SpiderMonkey and after that we could see about bringing them into Componentize-JS.
* Action Items
    * Robin: Announce a vote at next meeting for Chair and the nomination process
